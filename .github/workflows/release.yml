# Release
#
# Publish a GitHub release when a `release/*` branch is merged into `main` or on workflow dispatch.
#
# References:
#
# - https://cli.github.com/manual/gh_release_create
# - https://docs.github.com/actions/using-workflows/events-that-trigger-workflows#pull_request
# - https://docs.github.com/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch
# - https://docs.github.com/actions/using-workflows/using-github-cli-in-workflows
# - https://github.com/actions/checkout
# - https://github.com/actions/github-script
# - https://github.com/bdougie/close-issues-based-on-label
# - https://github.com/dawidd6/action-delete-branch
# - https://github.com/octokit/graphql-action

---
name: release
on:
  pull_request:
    branches:
      - main
    types:
      - closed
  workflow_dispatch:
    inputs:
      pr:
        description: pull request number
        required: true
      ref:
        description: full commit sha
        required: true
permissions:
  contents: write
  issues: write
  packages: read
env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
jobs:
  metadata:
    if:
      github.event_name == 'workflow_dispatch' || (startsWith(github.head_ref, 'release/') &&
      github.event.pull_request.merged)
    runs-on: ubuntu-latest
    outputs:
      prerelease: ${{ steps.prerelease.outputs.result }}
      tag: ${{ steps.tag.outputs.result }}
      version: ${{ steps.version.outputs.result }}
    steps:
      - id: checkout
        name: Checkout ${{ env.REF }}
        uses: actions/checkout@v3.0.2
        with:
          ref: ${{ env.REF }}
      - id: version
        name: Get version
        run: echo "::set-output name=result::$(jq .version package.json -r)"
      - id: tag
        name: Get release tag
        run: echo "::set-output name=result::${{ steps.version.outputs.result }}"
      - id: dist-tag
        name: Get dist tag
        uses: ./
        with:
          target: ${{ steps.version.outputs.result }}
      - id: prerelease
        name: Check for prerelease
        uses: actions/github-script@v6.1.0
        env:
          DIST_TAG: ${{ steps.dist-tag.outputs.tag }}
        with:
          # todo: calculate number of prereleases to include in release notes
          script: return !!process.env.DIST_TAG
  publish:
    needs: metadata
    runs-on: ubuntu-latest
    environment:
      name: production
      url:
        ${{ format('{0}/{1}/releases/tag/{2}', github.server_url, github.repository,
        needs.metadata.outputs.tag) }}
    env:
      NOTES_FILE: ./RELEASE_NOTES.md
      REF: ${{ github.event.inputs.ref || github.head_ref }}
      TAG: ${{ needs.metadata.outputs.tag }}
    steps:
      - id: checkout
        name: Checkout ${{ env.REF }}
        uses: actions/checkout@v3.0.2
        with:
          fetch-depth: 0
          ref: ${{ env.REF }}
      - id: yarn
        name: Install dependencies
        run: yarn
        env:
          HUSKY: 0
          NODE_AUTH_TOKEN: ${{ env.GITHUB_TOKEN }}
      - id: pack
        name: Pack project
        run: yarn pack -o %s-%v.tgz
        env:
          NODE_ENV: production
          NODE_NO_WARNINGS: 1
          NODE_OPTIONS: --es-module-specifier-resolution=node
      - id: release-notes
        name: Generate release notes
        # todo: handle prereleases
        run: yarn conventional-changelog -o $NOTES_FILE
        env:
          TS_NODE_PROJECT: ./tsconfig.tsnode.json
      - id: tag
        name: Create annotated tag
        uses: actions/github-script@v6.1.0
        env:
          VERSION: ${{ needs.metadata.outputs.version }}
        with:
          script: |
            const commit = await github.request('GET /repos/{owner}/{repo}/commits/{ref}', {
              ...context.repo,
              ref: context.payload.inputs?.ref ?? context.payload.pull_request.merge_commit_sha
            })

            console.log('commit', commit.data)

            const tag = await github.rest.git.createTag({
              ...context.repo,
              message: `release: @${context.payload.repository.full_name}@${process.env.VERSION}`,
              object: commit.data.sha,
              tag: process.env.TAG,
              tagger: commit.data.commit.committer,
              type: 'commit'
            })

            console.log('tag', tag.data)

            await github.rest.git.createRef({
              ...context.repo,
              ref: `refs/tags/${process.env.TAG}`,
              sha: tag.data.sha
            })
      - id: publish
        name: Publish release
        run: gh release create $TAG *.tgz -t=$TAG -F=$NOTES_FILE -p=$PRERELEASE
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_REPO_ADMIN }}
          PRERELEASE: ${{ needs.metadata.outputs.prerelease }}
  cleanup:
    needs: [metadata, publish]
    runs-on: ubuntu-latest
    steps:
      - id: query-linked-issues
        name: Query linked issues
        uses: octokit/graphql-action@v2.2.22
        with:
          query: |
            query ($owner: String!, $repo: String!, $pr: Int!, $limit: Int = 20) {
              repository(owner: $owner, name: $repo) {
                pullRequest(number: $pr) {
                  closingIssuesReferences(
                    first: $limit
                    orderBy: { direction: ASC, field: CREATED_AT }
                  ) {
                    edges {
                      node {
                        number
                      }
                    }
                  }
                }
              }
            }
          owner: ${{ github.repository_owner }}
          pr: ${{ github.event.inputs.pr || github.event.number }}
          repo: ${{ github.event.repository.name }}
      - id: label-linked-issues
        name: Label linked issues
        uses: actions/github-script@v6.1.0
        env:
          DATA: ${{ steps.query-linked-issues.outputs.data }}
          PRERELEASE: ${{ needs.metadata.outputs.prerelease }}
        with:
          script: |
            const { closingIssuesReferences } = JSON.parse(process.env.DATA).repository.pullRequest

            const issues = closingIssuesReferences.edges.map(edge => edge.node.number)
            const prerelease = JSON.parse(process.env.PRERELEASE || 'false')

            for (const issue_number of issues) {
              await github.rest.issues.addLabels({
                ...context.repo,
                issue_number,
                labels: [`status:${prerelease ? 'pre' : ''}released`]
              })
            }
      - id: close-released-issues
        name: Close released issues
        uses: bdougie/close-issues-based-on-label@master
        env:
          LABEL: status:${{ (needs.metadata.outputs.prerelease && 'prereleased') || 'released' }}
      - id: delete-release-branch
        name: Delete release/${{ needs.metadata.outputs.version }}
        uses: dawidd6/action-delete-branch@v3.1.0
        with:
          branches: release/
          soft_fail: true
          suffix: ${{ needs.metadata.outputs.version }}
